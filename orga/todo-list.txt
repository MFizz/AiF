1. Agent
    (Done) - Feature Vektor für Abenteuer implementieren (am besten zuerst). Kann wie eine Map {Abenteuer:Features} gespeichert werden. Die Klasse Features muss zumindest Kosten,erwarteter Gewinn, in Koalition (ja/nein), fehlende Power (falls was fehlt), usw enthalten. Auf jeden Fall gut über weitere mögliche Features nachdenken.
    - (in Progress-Mihail) Schätzfunktion (einfach und Koalition-Bedingt) "estimateValue(Adventure, Coalition(optional)) returns float" implementieren. 
          - Rounds left auch in schätzfunktion miteinbeziehen

    (Done) - Nutzenfunktion "utility(Adventure) returns float" implementueren
    (Done) - Funktion "chooseAdventures() returns [Adventure]" zur Auswahl der ersten 4 Abenteuern implementieren.

2. Modul coalition_utils
    - "bestCoalition([Coalition]) returns Coalition" zur Auswahl einer Koalition (distributiver Ansatz) implementieren.

    (Done) - Klasse Coalition implementieren (am besten zuerst). Sie soll zumindest Agenten, investierte Skill und Power pro Agent, zugehörige Abenteuer und Gewinn als Variablen speichern.
3. Modul coalition_utils - Part 2 (klasse Coalition muss schon implementiert sein)
    - Verhandlungsprozess als divideReward(Coalition) returns {key=Agent:value=float} implementieren
      - Excess power entfernen (gewichtet random)
      - virtuellen spieler für veto spieler implementieren
      - Gewinn fair verteilen

    (Done) - "buildCoalitions(Adventure,[Agents]) returns [[Coalition]]" zur Erstellung aller mögliche Koalitionen implementieren

4. Modul zur Steuerung (World) implementieren und alle notwendige Funktionen aufrufen (auch wenn sie nicht komplett implementiert sind)
    - Beste Koalitionen mit coalition_utils.bestCoalition() erhalten

    (Done) - ein paar Agenten und Abenteuern initialisieren.
    (Done) - Agent.chooseAdventures() für jeden Agent aufrufen um Bewerbungen zu erhalten
    (Done) - für jedes Abenteuer Koalitionen mit coalition_utils.buildCoalitions() erstellen
    - Funktion zur update von Feature Vectors in Klasse Agent schreiben, die abhängig von Resultat nach Coalition Forming und Shapely Value den Feature Vector aktualisiert. Falls der Feature Vektor im Agent noch nicht fertig implementiert ist, kann diese Funktion auch später implementiert werden.
    - Rounds left in Booker speichern
    
    
    (Done) - Initialisierung verbessern:
        (Done) - Power von Abenteuern soll binomial oder geometric verteilt werden (und nicht total random), und falls notwendig, ein grosses Abenteuer manuell erstellen
        (Done) - Power in einem Abenteuer soll an Skills random verteilt werden
        (Done) - Reward von Abenteuer hängt super-linear von Power ab 
        (Done) - Gesamte Power aller Agenten soll pro Skill ein fixen Teil von gesamten Power aller Abenteuern sein (Vorschlag: 40-50%)
        (Done) - Power von Agenten soll auch binomial oder geometric verteilt werden.

